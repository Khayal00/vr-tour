const pos = latLonToCartesian(h.lat || 0, h.lon || 0, 3.5);
      // small outward tweak (values slightly >1 push hotspot a bit away from sphere to reduce distortion)
      const tweak = 1.02; // try 1.02 or 0.98 depending on distortion
      const adjX = pos.x * tweak;
      const adjY = pos.y * tweak;
      const adjZ = pos.z * tweak;
      ent.setAttribute('position', `${adjX.toFixed(3)} ${adjY.toFixed(3)} ${adjZ.toFixed(3)}`);
      ent.setAttribute('data-target', h.target);
      ent.setAttribute('look-at', '#camera');
      hotspotsRoot.appendChild(ent);<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>VR 360 Tour - A-Frame (Black Fade Transition)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <style>
    html,body { height:100%; margin:0; font-family: Arial, sans-serif; direction: rtl; }
    #overlay {
      position: absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background: linear-gradient(0deg, rgba(0,0,0,0.85), rgba(0,0,0,0.6));
      color:#fff; z-index:10; flex-direction:column; gap:18px;
    }
    #welcomeBox { text-align:center; max-width:720px; padding:20px; }
    #title { font-size:28px; margin-bottom:8px; }
    #subtitle { font-size:16px; opacity:0.9; }
    #progressBar {
      width:80%; height:14px; background:rgba(255,255,255,0.15); border-radius:8px; overflow:hidden; margin-top:16px;
    }
    #progressFill { width:0%; height:100%; background:linear-gradient(90deg, rgba(255,255,255,0.18), rgba(255,255,255,0.32)); transition:width 200ms ease; }
    #startBtn {
      margin-top:14px; padding:10px 18px; border-radius:8px; border:none; background:#1e90ff; color:white; cursor:pointer;
      font-size:16px;
    }
    #instructions { font-size:13px; opacity:0.9; margin-top:10px; }
    @media (max-width:600px){ #title{font-size:22px;} #subtitle{font-size:14px;} }
  </style>
</head>
<body>
  <!-- Overlay / Preloader / Welcome -->
  <div id="overlay">
    <div id="welcomeBox">
      <div id="title">مرحباً بكم في الجولة الافتراضية</div>
      <div id="subtitle">التجربة تعمل على نظارات VR (Meta Quest) والموبايل والكمبيوتر — مرّر المؤشر على النقاط لتعريف المكان، واضغط أو انظر للنقطة للانتقال.</div>

      <div id="progressBar"><div id="progressFill"></div></div>
      <div id="progressText" style="margin-top:8px;">تحميل الصور: <span id="percent">0%</span></div>

      <button id="startBtn" disabled>ابدأ الجولة</button>
      <div id="instructions" style="margin-top:8px;">
        تحكم: لمس / نقرة / المؤشر على الكمبيوتر — أو استخدم ذراع تحكم النظارة (laser).<br>
        يمكنك تعديل مواقع الهوتسبوت في الكود ضمن مصفوفة `hotspotsData`.
      </div>
    </div>
  </div>

  <!-- A-Frame Scene -->
  <a-scene background="color: #000" vr-mode-ui="enabled: true">
    <!-- Camera + cursor (supports gaze & mouse) -->
    <a-entity id="cameraRig">
      <a-entity id="camera" camera look-controls position="0 1.6 0">
        <!-- Gaze cursor -->
        <a-entity id="gazeCursor"
          cursor="fuse: true; fuseTimeout: 1000"
          position="0 0 -1"
          geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
          material="color: white; shader: flat; opacity:0.9">
        </a-entity>

        <!-- Black fade plane attached to camera so it always covers view -->
        <a-plane id="blackFade" position="0 0 -0.6" width="4" height="4" material="color: black; opacity: 0; transparent: true" visible="false"></a-plane>
      </a-entity>

      <!-- Laser + controller support for Quest -->
      <a-entity laser-controls="hand: right" raycaster="objects: .clickable" line="opacity: 0.75"></a-entity>
      <a-entity laser-controls="hand: left" raycaster="objects: .clickable" line="opacity: 0.75"></a-entity>
    </a-entity>

    <!-- Single sky (we'll swap textures while black covers view) -->
    <a-sky id="sky" radius="5000" position="0 0 0" material="shader: flat; transparent: false; opacity:1"></a-sky>

    <!-- Container for hotspots -->
    <a-entity id="hotspotsRoot"></a-entity>

    <!-- small reticle for desktop when using mouse (optional) -->
    <a-entity id="desktopCursor" cursor="rayOrigin: mouse" raycaster="objects:.clickable" visible="false"></a-entity>

  </a-scene>

<script>
  // ---------- CONFIG ----------
  const scenes = {
    "Reception": "assets/Reception.jpg",
    "Living_Room": "assets/Living_Room.jpg",
    "Kitchen": "assets/Kitchen.jpg",
    "Corridor": "assets/Corridor.jpg",
    "Bedroom": "assets/Bedroom.jpg",
    "Bathroom": "assets/Bathroom.jpg"
  };

  const hotspotsData = {
    "Reception": [
      { label: "To Living Room", target: "Living_Room", lat: 0, lon: 60 }
    ],
    "Kitchen": [
      { label: "To Living Room", target: "Living_Room", lat: 10, lon: -80 }
    ],
    "Corridor": [
      { label: "To Living Room", target: "Living_Room", lat: 0, lon: 160 },
      { label: "To Bedroom", target: "Bedroom", lat: 5, lon: -30 },
      { label: "To Bathroom", target: "Bathroom", lat: -5, lon: -60 }
    ],
    "Living_Room": [
      { label: "To Reception", target: "Reception", lat: 0, lon: -110 },
      { label: "To Kitchen", target: "Kitchen", lat: 10, lon: 60 },
      { label: "To Corridor", target: "Corridor", lat: -5, lon: 150 }
    ],
    "Bedroom": [
      { label: "To Corridor", target: "Corridor", lat: 0, lon: 120 }
    ],
    "Bathroom": [
      { label: "To Corridor", target: "Corridor", lat: 0, lon: -140 }
    ]
  };

  const initialScene = "Reception"; // بداية الجولة

  // ---------- PRELOADER ----------
  const overlay = document.getElementById('overlay');
  const progressFill = document.getElementById('progressFill');
  const percentText = document.getElementById('percent');
  const startBtn = document.getElementById('startBtn');

  const imageUrls = Object.values(scenes);
  let loadedCount = 0;
  function preloadImages(urls, onComplete, onProgress){
    urls.forEach(url => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => { loadedCount++; onProgress(loadedCount, urls.length); if(loadedCount===urls.length) onComplete(); };
      img.onerror = () => { console.warn('Failed to load', url); loadedCount++; onProgress(loadedCount, urls.length); if(loadedCount===urls.length) onComplete(); };
      img.src = url;
    });
  }

  preloadImages(imageUrls, () => {
    startBtn.disabled = false;
  }, (loaded,total) => {
    const pct = Math.round(loaded/total*100);
    progressFill.style.width = pct + "%";
    percentText.innerText = pct + "%";
  });

  startBtn.addEventListener('click', () => {
    overlay.style.display = 'none';
    enterScene(initialScene);
  });

  document.addEventListener('keydown', e => {
    if((e.key === 'Enter' || e.key === ' ') && !startBtn.disabled){
      overlay.style.display = 'none';
      enterScene(initialScene);
    }
  });

  // ---------- UTILS: Lat/Lon -> Cartesian ----------
  function latLonToCartesian(latDeg, lonDeg, radius){
    const lat = latDeg * Math.PI/180;
    const lon = lonDeg * Math.PI/180;
    const x = radius * Math.cos(lat) * Math.sin(lon);
    const y = radius * Math.sin(lat);
    const z = radius * Math.cos(lat) * Math.cos(lon) * -1;
    return { x, y, z };
  }

  // ---------- HOTSPOT CREATION & INTERACTIONS ----------
  const sceneEl = document.querySelector('a-scene');
  const hotspotsRoot = document.getElementById('hotspotsRoot');
  const camera = document.getElementById('camera');
  const blackFade = document.getElementById('blackFade');

  // Component to keep hotspot elements visually constant size regardless of distance
  AFRAME.registerComponent('constant-size', {
    schema: { base: { type: 'number', default: 0.9 } },
    init: function() {
      this.camEl = document.querySelector('#camera');
      this.vecCam = new THREE.Vector3();
      this.vecObj = new THREE.Vector3();
    },
    tick: function() {
      if (!this.el.object3D || !this.camEl) return;
      this.camEl.object3D.getWorldPosition(this.vecCam);
      this.el.object3D.getWorldPosition(this.vecObj);
      const dist = this.vecCam.distanceTo(this.vecObj);
      // scale factor: tweak 0.18 so that at radius ~3.5 size is reasonable; multiply by base
      const scale = Math.max(0.2, dist * 0.18) * (this.data.base);
      this.el.object3D.scale.set(scale, scale, scale);
    }
  });


  function makeHotspot(h) {
    const hotspotRoot = document.createElement('a-entity');
    hotspotRoot.setAttribute('look-at', '#camera');
    hotspotRoot.setAttribute('constant-size', 'base: 1');

    // Outer pulsing layer: use a slightly larger quad but with low opacity
    const pulse = document.createElement('a-entity');
    pulse.setAttribute('geometry', 'primitive: plane; height: 1; width: 1');
    pulse.setAttribute('material',
      `src: url(assets/hotspot.png);
       shader: flat;
       transparent: true;
       alphaTest: 0.05;
       depthTest: false;
       depthWrite: false;
       side: double;
       opacity: 0.45`);
    pulse.setAttribute('animation__pulse', 'property: scale; dir: alternate; dur: 1100; easing: easeInOutSine; loop: true; to: 1.45 1.45 1.45; from: 1 1 1');

    // Inner icon (click target)
    const icon = document.createElement('a-entity');
    icon.setAttribute('geometry', 'primitive: plane; height: 0.7; width: 0.7');
    icon.setAttribute('material',
      `src: url(assets/hotspot.png);
       shader: flat;
       transparent: true;
       alphaTest: 0.05;
       depthTest: false;
       depthWrite: false;
       side: double`);
    icon.classList.add('clickable');

    // label
    const label = document.createElement('a-entity');
    label.setAttribute('text', `value: ${h.label}; align: center; wrapCount: 20; width: 2`);
    label.setAttribute('position', `0 0.55 0`);
    label.setAttribute('visible', false);

    // Hover interactions
    icon.addEventListener('mouseenter', () => {
      icon.setAttribute('animation__hover', 'property: scale; to: 1.15 1.15 1.15; dur: 150; easing: easeOutQuad');
      label.setAttribute('visible', true);
    });
    icon.addEventListener('mouseleave', () => {
      icon.setAttribute('animation__hover', 'property: scale; to: 1 1 1; dur: 120; easing: easeOutQuad');
      label.setAttribute('visible', false);
    });

    // Click
    icon.addEventListener('click', (evt) => {
      evt.stopPropagation && evt.stopPropagation();
      const tgt = hotspotRoot.getAttribute('data-target');
      if (tgt) {
        disableHotspots();
        fadeToScene(tgt);
      }
    });

    hotspotRoot.appendChild(pulse);
    hotspotRoot.appendChild(icon);
    hotspotRoot.appendChild(label);

    return hotspotRoot;
  }

  function disableHotspots() {
    hotspotsRoot.querySelectorAll('.clickable').forEach(el => { el.classList.remove('clickable'); el.classList.add('disabled'); });
  }
  function enableHotspots() {
    hotspotsRoot.querySelectorAll('.disabled').forEach(el => { el.classList.remove('disabled'); el.classList.add('clickable'); });
  }

  function buildHotspotsFor(sceneName) {
    while (hotspotsRoot.firstChild) hotspotsRoot.removeChild(hotspotsRoot.firstChild);

    const list = hotspotsData[sceneName] || [];
    list.forEach(h => {
      const pos = latLonToCartesian(h.lat || 0, h.lon || 0, 3.5);
      const ent = makeHotspot(h);
      ent.setAttribute('position', `${pos.x.toFixed(3)} ${pos.y.toFixed(3)} ${pos.z.toFixed(3)}`);
      ent.setAttribute('data-target', h.target);
      ent.setAttribute('look-at', '#camera');
      hotspotsRoot.appendChild(ent);
    });
  }

  // ---------- BLACK FADE TRANSITION ----------
  let isTransitioning = false;
  function wait(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

  async function fadeToScene(targetName) {
    if (isTransitioning) return;
    if (!scenes[targetName]) {
      console.warn('Unknown scene target:', targetName);
      enableHotspots();
      return;
    }
    isTransitioning = true;
    const fadeDur = 700; // total fade duration in ms (black in + black out)
    const half = Math.round(fadeDur/2);

    // ensure black plane visible and material ready
    blackFade.setAttribute('visible', true);
    blackFade.setAttribute('material', 'transparent', true);

    // helper animator using requestAnimationFrame for reliable repeated fades
    function animateOpacity(el, from, to, dur){
      return new Promise(resolve => {
        const start = performance.now();
        function step(now){
          const t = Math.min(1, (now - start) / dur);
          // easeInOut (cosine)
          const eased = 0.5 - 0.5 * Math.cos(Math.PI * t);
          const val = from + (to - from) * eased;
          el.setAttribute('material', 'opacity', val);
          if (t < 1) requestAnimationFrame(step);
          else resolve();
        }
        requestAnimationFrame(step);
      });
    }

    try {
      // fade to black
      await animateOpacity(blackFade, 0, 1, half);

      // swap sky texture while view is black
      sky.setAttribute('src', scenes[targetName]);

      // rebuild hotspots while black covers view
      buildHotspotsFor(targetName);

      // tiny pause to ensure texture applied
      await new Promise(r => setTimeout(r, 80));

      // fade back to scene
      await animateOpacity(blackFade, 1, 0, half);

      // hide black plane and re-enable interactions
      blackFade.setAttribute('visible', false);
    } catch (err) {
      console.error('Fade error', err);
      blackFade.setAttribute('visible', false);
    }

    isTransitioning = false;
    enableHotspots();
  }

  // initial enter scene (set sky and create hotspots)
  function enterScene(sceneName) {
    if (!scenes[sceneName]) {
      console.error('Initial scene not found:', sceneName);
      return;
    }
    sky.setAttribute('src', scenes[sceneName]);
    sky.setAttribute('material', 'opacity', 1);
    buildHotspotsFor(sceneName);

    const deskCursor = document.getElementById('desktopCursor');
    if (AFRAME.utils.device.isDesktop()) {
      deskCursor.setAttribute('visible', true);
    } else {
      deskCursor.setAttribute('visible', false);
    }
  }

  sceneEl.addEventListener('loaded', () => {
    sky.setAttribute('material', 'shader', 'flat');
    blackFade.setAttribute('material', 'shader', 'flat');
  });

  window.vrTour = { enterScene, fadeToScene, hotspotsData, scenes };

  if (overlay.style.display === 'none') enterScene(initialScene);
</script>
</body>
</html>
